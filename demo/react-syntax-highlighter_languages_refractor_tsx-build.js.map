{"version":3,"sources":["webpack:///./node_modules/refractor/lang/jsx.js","webpack:///./node_modules/refractor/lang/typescript.js","webpack:///./node_modules/refractor/lang/tsx.js"],"names":["jsx","Prism","javascript","util","clone","languages","extend","tag","pattern","inside","insertBefore","spread","punctuation","attr-value","script","script-punctuation","alias","rest","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","Token","hooks","add","env","language","module","exports","displayName","aliases","typescript","keyword","builtin","ts","refractorJsx","__webpack_require__","refractorTypescript","tsx","register"],"mappings":"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","file":"react-syntax-highlighter_languages_refractor_tsx-build.js","sourcesContent":["'use strict'\n\nmodule.exports = jsx\njsx.displayName = 'jsx'\njsx.aliases = []\nfunction jsx(Prism) {\n  ;(function(Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript)\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript)\n    Prism.languages.jsx.tag.pattern = /<\\/?(?:[\\w.:-]+\\s*(?:\\s+(?:[\\w.:-]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s{'\">=]+|\\{(?:\\{(?:\\{[^}]*\\}|[^{}])*\\}|[^{}])+\\}))?|\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}))*\\s*\\/?)?>/i\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i\n    Prism.languages.jsx.tag.inside[\n      'attr-value'\n    ].pattern = /=(?!\\{)(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">]+)/i\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-name',\n      {\n        spread: {\n          pattern: /\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}/,\n          inside: {\n            punctuation: /\\.{3}|[{}.]/,\n            'attr-value': /\\w+/\n          }\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-value',\n      {\n        script: {\n          // Allow for two levels of nesting\n          pattern: /=(\\{(?:\\{(?:\\{[^}]*\\}|[^}])*\\}|[^}])+\\})/i,\n          inside: {\n            'script-punctuation': {\n              pattern: /^=(?={)/,\n              alias: 'punctuation'\n            },\n            rest: Prism.languages.jsx\n          },\n          alias: 'language-javascript'\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n    // The following will handle plain text inside tags\n    var stringifyToken = function(token) {\n      if (!token) {\n        return ''\n      }\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function(tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{'\n          ) {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token)\n            // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            tokens[i] = new Prism.Token(\n              'plain-text',\n              plainText,\n              null,\n              plainText\n            )\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function(env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = typescript\ntypescript.displayName = 'typescript'\ntypescript.aliases = ['ts']\nfunction typescript(Prism) {\n  Prism.languages.typescript = Prism.languages.extend('javascript', {\n    // From JavaScript Prism keyword list and TypeScript language spec: https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#221-reserved-words\n    keyword: /\\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield|module|declare|constructor|namespace|abstract|require|type)\\b/,\n    builtin: /\\b(?:string|Function|any|number|boolean|Array|symbol|console)\\b/\n  })\n  Prism.languages.ts = Prism.languages.typescript\n}\n","'use strict'\nvar refractorJsx = require('./jsx.js')\nvar refractorTypescript = require('./typescript.js')\nmodule.exports = tsx\ntsx.displayName = 'tsx'\ntsx.aliases = []\nfunction tsx(Prism) {\n  Prism.register(refractorJsx)\n  Prism.register(refractorTypescript)\n  var typescript = Prism.util.clone(Prism.languages.typescript)\n  Prism.languages.tsx = Prism.languages.extend('jsx', typescript)\n}\n"],"sourceRoot":""}